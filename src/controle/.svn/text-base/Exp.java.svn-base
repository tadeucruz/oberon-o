/*
 * Generated by classgen, version 1.3
 * 24/09/10 22:45
 */
package controle;

import java.util.HashMap;

import principal.goo;
import type.Type;

public abstract class Exp {

	public static Type INT = Decla.INT;
	public static Type BOOL = Decla.BOOL;
	public static Type VOID = Decla.VOID;
	public static Type ERROR = Decla.ERROR;
	public static Type INTARRAY = Decla.INTARRAY;
	public static Type BOOLARRAY = Decla.BOOLARRAY;
	public Type _type = Decla.VOID;
	public int width;
	public int offset;
	public int IfouWhile = 0;
	public String t_label = "FALL";
	public String f_label = "FALL";
	public static int label_count = Com.label_count;

	public int new_label() {
		return ++label_count;
	}

	public static HashMap<Exp, Temporarios> tabela = new HashMap<Exp, Temporarios>();

	public Exp getExp() {
		throw new ClassCastException("tried to call abstract method");
	}

	public void setExp(Exp exp) {
		throw new ClassCastException("tried to call abstract method");
	}

	public String getTipo() {
		throw new ClassCastException("tried to call abstract method");
	}

	public void setTipo(String tipo) {
		throw new ClassCastException("tried to call abstract method");
	}

	public Exp getExp2() {
		throw new ClassCastException("tried to call abstract method");
	}

	public void setExp2(Exp exp2) {
		throw new ClassCastException("tried to call abstract method");
	}

	public int getId() {
		throw new ClassCastException("tried to call abstract method");
	}

	public void setId(int id) {
		throw new ClassCastException("tried to call abstract method");
	}

	public String getPrec() {
		throw new ClassCastException("tried to call abstract method");
	}

	public void setPrec(String prec) {
		throw new ClassCastException("tried to call abstract method");
	}

	public Decla getDecla() {
		throw new ClassCastException("tried to call abstract method");
	}

	public void setDecla(Decla decla) {
		throw new ClassCastException("tried to call abstract method");
	}

	public int getValor() {
		throw new ClassCastException("tried to call abstract method");
	}

	public void setValor(int valor) {
		throw new ClassCastException("tried to call abstract method");
	}

	public String getSize() {
		throw new ClassCastException("tried to call abstract method");
	}

	public void setSize(String size) {
		throw new ClassCastException("tried to call abstract method");
	}

	public boolean getBooo() {
		throw new ClassCastException("tried to call abstract method");
	}

	public void setBooo(boolean booo) {
		throw new ClassCastException("tried to call abstract method");
	}

	public String toString() {
		return toString("");
	}

	public abstract String toString(String tab);

	public abstract StringBuffer to_postfix();

	public boolean check_const() {
		return false;
	}

	protected int calc(String op, int v1) {
		if (op.equals("+")) {
			return +v1;
		} else if (op.equals("-")) {
			return -v1;
		} else {
			return ~v1;
		}
	}

	protected int calc(String op, int v1, int v2) {
		if (op.equals("+")) {
			return v1 + v2;
		} else if (op.equals("-")) {
			return v1 - v2;
		} else if (op.equals("*")) {
			return v1 * v2;
		} else if (op.equals("/")) {
			return v1 / v2;
		} else if (op.equals(">")) {
			if (v1 > v2)
				return 1;
			else
				return 0;
		} else if (op.equals("<")) {
			if (v1 < v2)
				return 1;
			else
				return 0;
		} else if (op.equals(">=")) {
			if (v1 >= v2)
				return 1;
			else
				return 0;
		} else if (op.equals("<=")) {
			if (v1 <= v2)
				return 1;
			else
				return 0;
		} else if (op.equals("=")) {
			if (v1 == v2)
				return 1;
			else
				return 0;
		} else if (op.equals("#")) {
			if (v1 != v2)
				return 1;
			else
				return 0;
		} else {
			return v1 % v2;
		}
	}

	public abstract Type type_check();

	public Type type() {
		return _type;
	}

	public int cvalue;
	// public boolean is_const;

	public String addr;

	public void gen() {
		System.out.println("Implenetar: " + this.getClass());
		goo.podeContinuar = false;
	}

	@Override
	public abstract boolean equals(Object obj);

}
